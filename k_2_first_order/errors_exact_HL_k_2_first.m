function [err_u,err_s] = errors_exact_HL_k_2_first(p,t,t2,ed,t_e,basis_p1,basis_rt1,basis_p2,basis_nd1,u_h,u_vec_r,u_vec_th,u_vec_z,s_h,s_vec_r,s_vec_th,s_vec_z,n)
% ERRORS_EXACT_HL_K_2_FIRST - Calculate the errors of our solution
% (u_h, s_h) compared to the exact solution (u, s).
%   Hodge Laplacian k = 2 case, first order
%
% Syntax:
%     [err,grad_err,max_err] = 
%         errors_exact_HL_k_2_first(p,t,t2,ed,t_e,basis_p1,basis_rt1,basis_p2,basis_nd1,u_h,u_vec_r,u_vec_th,u_vec_z,s_h,s_vec_r,s_vec_th,s_vec_z,n)
% Inputs:
%     p - a 2xNumNodes matrix representing nodal coordinates.
%     t - a 4xNumTriangles matrix representing the element connectivity in 
%         terms of node IDs. The end row of T represents the geometry face ID 
%         to which the element belongs.
%     t_ed - a 3xNumTriangles matrix representing the which edges
%         correspond to which triangles. t_ed(i,T) represents the ith edge
%         in triangle T.
%     basis_nodes - a matrix representing piece-wise basis functions for
%         each node in each triangle. basis(i,:,T) represents the
%         pieceiwise basis function for the ith node in triangle T.
%     basis_NP1_edges - a matrix representing piece-wise basis functions
%         for each edge in each triangle for the weighted fourier Nedelec
%         and P1 space. basis(i,:,T) represents the pieceiwise basis
%         function for the ith edge in triangle T.
%     basis_RT_edges - a matrix representing piece-wise basis functions
%         for each edge in each triangle for the weighted fourier Raviart 
%         Thomas space. basis(i,:,T) represents the pieceiwise basis 
%         function for the ith edge in triangle T.
%     basis_triangles - a vector representing piece-wise basis functions
%         for edge triangle. basis(1,T) represents the piecewise basis
%         function for the Tth triangle.
%     u_h - approximated solution of u
%     u_vec_r - exact solution u vector r component
%     u_vec_r - exact solution u vector theta component
%     u_vec_z - exact solution u vector z component
%     s_h - approximated solution of s
%     s_vec_r - exact solution s vector r component
%     s_vec_r - exact solution s vector theta component
%     s_vec_z - exact solution s vector z component
%     n - Fourier mode
%
% Outputs:
%    err_u - L2 error for u approximation
%    err_v - L2 error for v approximation
%
% Author: Nicole Stock
% Date: Fall 2020

[~,nodes] = size(p);
[~,triangles] = size(t);
[edges,~] = size(ed);
integral_u = 0;
integral_s = 0;

for T = 1:triangles
    
    % get coordinates of triangle T
    coordinates = zeros(3,2);
    for N = 1:3
        node = t(N,T);
        % get x,y coordinates
        coordinates(N,:) = p(:,node);
    end
        
    [X,Y,Wx,Wy] = triquad(7, coordinates);

    % s_h (Bh1 space)

    % P2 Basis Function
    basis_p2_r = @(r,z,i) (-1./n).*(basis_p2(1,i,T).*r.^2 ...
        + basis_p2(2,i,T).*r.*z ...
        + basis_p2(3,i,T).*z.^2 + basis_p2(4,i,T).*r ...
        + basis_p2(5,i,T).*z + basis_p2(6,i,T));
    basis_p2_th = @(r,z,i) basis_p2(1,i,T).*r.^2 + basis_p2(2,i,T).*r.*z ...
        + basis_p2(3,i,T).*z.^2 ...
        + basis_p2(4,i,T).*r + basis_p2(5,i,T).*z ...
        + basis_p2(6,i,T);
    % basis_p2_z = 0;
    
    % ND1 Basis Function
    basis_nd1_r = @(r,z,i) (1./n).*(basis_nd1(1,i,T).*r.^2 ...
        + basis_nd1(2,i,T).*r.*z + basis_nd1(3,i,T).*r ...
        - basis_nd1(7,i,T).*r.^2.*z - basis_nd1(8,i,T).*r.*z.^2);
    %basis_nd1_th = 0;
    basis_nd1_z = @(r,z,i) (1./n).*(basis_nd1(4,i,T).*r.^2 ...
        + basis_nd1(5,i,T).*r.*z + basis_nd1(6,i,T).*r ...
        + basis_nd1(7,i,T).*r.^3 + basis_nd1(8,i,T).*r.^2.*z);
    
    % compute approximations for s_h
    approx_r_s = @(r,z) s_h(2*edges+2*triangles+t(1,T)).*basis_p2_r(r,z,1) ...
        + s_h(2*edges+2*triangles+t(2,T)).*basis_p2_r(r,z,2) ...
        + s_h(2*edges+2*triangles+t(3,T)).*basis_p2_r(r,z,3) ...
        + s_h(2*edges+2*triangles+nodes+t2(1,T)).*basis_p2_r(r,z,4) ...
        + s_h(2*edges+2*triangles+nodes+t2(2,T)).*basis_p2_r(r,z,5) ...
        + s_h(2*edges+2*triangles+nodes+t2(3,T)).*basis_p2_r(r,z,6) ...
        + s_h(t_e(T,1)).*basis_nd1_r(r,z,1) ...
        + s_h(edges+t_e(T,1)).*basis_nd1_r(r,z,2) ...
        + s_h(t_e(T,2)).*basis_nd1_r(r,z,3) ...
        + s_h(edges+t_e(T,2)).*basis_nd1_r(r,z,4) ...
        + s_h(t_e(T,3)).*basis_nd1_r(r,z,5) ...
        + s_h(edges+t_e(T,3)).*basis_nd1_r(r,z,6) ...
        + s_h(2*edges+T).*basis_nd1_r(r,z,7) ...
        + s_h(2*edges+triangles+T).*basis_nd1_r(r,z,8);

    approx_th_s = @(r,z) s_h(2*edges+2*triangles+t(1,T)).*basis_p2_th(r,z,1) ...
        + s_h(2*edges+2*triangles+t(2,T)).*basis_p2_th(r,z,2) ...
        + s_h(2*edges+2*triangles+t(3,T)).*basis_p2_th(r,z,3) ...
        + s_h(2*edges+2*triangles+nodes+t2(1,T)).*basis_p2_th(r,z,4) ...
        + s_h(2*edges+2*triangles+nodes+t2(2,T)).*basis_p2_th(r,z,5) ...
        + s_h(2*edges+2*triangles+nodes+t2(3,T)).*basis_p2_th(r,z,6);
        
    approx_z_s = @(r,z) s_h(t_e(T,1)).*basis_nd1_z(r,z,1) ...
        + s_h(edges+t_e(T,1)).*basis_nd1_z(r,z,2) ...
        + s_h(t_e(T,2)).*basis_nd1_z(r,z,3) ...
        + s_h(edges+t_e(T,2)).*basis_nd1_z(r,z,4) ...
        + s_h(t_e(T,3)).*basis_nd1_z(r,z,5) ...
        + s_h(edges+t_e(T,3)).*basis_nd1_z(r,z,6) ...
        + s_h(2*edges+T).*basis_nd1_z(r,z,7) ...
        + s_h(2*edges+triangles+T).*basis_nd1_z(r,z,8);
            
    % find L2 Error for s
    integrand_s =@(r,z) ((s_vec_r(r,z) - approx_r_s(r,z)).^2 ...
        + (s_vec_th(r,z) - approx_th_s(r,z)).^2 ...
        + (s_vec_z(r,z) - approx_z_s(r,z)).^2).*r;
    
    integral_s = integral_s + Wx'*feval(integrand_s,X,Y)*Wy;    
    
    % u_h (Ch1 space)
    
    % Rt1 Basis Function
    basis_rt1_r = @(r,z,i) basis_rt1(1,i,T).*r + basis_rt1(2,i,T).*z ...
        + basis_rt1(3,i,T) + basis_rt1(7,i,T).*r.*r + basis_rt1(8,i,T).*r.*z;
    basis_rt1_th = @(r,z,i) (1./n).*(basis_rt1(1,i,T).*r + basis_rt1(2,i,T).*z ...
        + basis_rt1(3,i,T) + basis_rt1(7,i,T).*r.*r + basis_rt1(8,i,T).*r.*z);
    basis_rt1_z = @(r,z,i) basis_rt1(4,i,T).*r + basis_rt1(5,i,T).*z ...
        + basis_rt1(6,i,T) + basis_rt1(7,i,T).*r.*z + basis_rt1(8,i,T).*z.*z;

    % P1 Basis Function
    basis_p1_th = @(r,z,i) (1./n).*(basis_p1(1,i,T).*r.*r ... 
        + basis_p1(2,i,T).*r.*z + basis_p1(3,i,T).*r);
    % basis_p1_r = 0 , basis_p1_z = 0

    % compute approximation for u_h
    approx_r_u = @(r,z) u_h(t_e(T,1)).*basis_rt1_r(r,z,1) ...
        + u_h(edges+t_e(T,1)).*basis_rt1_r(r,z,2)...
        + u_h(t_e(T,2)).*basis_rt1_r(r,z,3) ...
        + u_h(edges+t_e(T,2)).*basis_rt1_r(r,z,4)...
        + u_h(t_e(T,3)).*basis_rt1_r(r,z,5) ...
        + u_h(edges+t_e(T,3)).*basis_rt1_r(r,z,6)...
        + u_h(2*edges+T).*basis_rt1_r(r,z,7)...
        + u_h(2*edges+triangles+T).*basis_rt1_r(r,z,8);
    
    approx_th_u = @(r,z) u_h(t_e(T,1)).*basis_rt1_th(r,z,1) ...
        + u_h(edges+t_e(T,1)).*basis_rt1_th(r,z,2)...
        + u_h(t_e(T,2)).*basis_rt1_th(r,z,3) ...
        + u_h(edges+t_e(T,2)).*basis_rt1_th(r,z,4)...
        + u_h(t_e(T,3)).*basis_rt1_th(r,z,5) ...
        + u_h(edges+t_e(T,3)).*basis_rt1_th(r,z,6)...
        + u_h(2*edges+T).*basis_rt1_th(r,z,7)...
        + u_h(2*edges+triangles+T).*basis_rt1_th(r,z,8)...
        + u_h(2*edges+2*triangles+t(1,T)).*basis_p1_th(r,z,1)...
        + u_h(2*edges+2*triangles+t(2,T)).*basis_p1_th(r,z,2)...
        + u_h(2*edges+2*triangles+t(3,T)).*basis_p1_th(r,z,3);
    
    approx_z_u = @(r,z) u_h(t_e(T,1)).*basis_rt1_z(r,z,1) ...
        + u_h(edges+t_e(T,1)).*basis_rt1_z(r,z,2)...
        + u_h(t_e(T,2)).*basis_rt1_z(r,z,3) ...
        + u_h(edges+t_e(T,2)).*basis_rt1_z(r,z,4)...
        + u_h(t_e(T,3)).*basis_rt1_z(r,z,5) ...
        + u_h(edges+t_e(T,3)).*basis_rt1_z(r,z,6)...
        + u_h(2*edges+T).*basis_rt1_z(r,z,7)...
        + u_h(2*edges+triangles+T).*basis_rt1_z(r,z,8);

    % find L2 Error for u
    integrand_u =@(r,z) ((u_vec_r(r,z) - approx_r_u(r,z)).^2 ...
        + (u_vec_th(r,z) - approx_th_u(r,z)).^2 ...
        + (u_vec_z(r,z) - approx_z_u(r,z)).^2).*r;
    
    integral_u = integral_u + Wx'*feval(integrand_u,X,Y)*Wy;
end
err_s = sqrt(integral_s);
err_u = sqrt(integral_u);
% end