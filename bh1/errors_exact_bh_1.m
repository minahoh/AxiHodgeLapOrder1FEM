function [err] = errors_exact_bh_1(p,t,p2,t2,ed,t_e,basis_p2,basis_nd1,x,u_vec_r,u_vec_th,u_vec_z,n)
% ERRORS_EXACT_BH_1 - Calculate the errors of our solution x
% compared to the exact solution u.
%
% Syntax:
%     [err] = 
%         errors_exact_bh_1(p,t,t_ed,basis,x,u_vec_r,u_vec_z)
% Inputs:
%     p - a 2xNumNodes matrix representing nodal coordinates.
%     t - a 4xNumTriangles matrix representing the element connectivity in 
%         terms of node IDs. The end row of T represents the geometry face ID 
%         to which the element belongs
%     ed - a 2xNumEdges matrix representing each edge as a row with
%         starting node in column 1 and the ending node in column 2.
%     t_e - a NumTrianglesx3 matrix representing the which edges
%         correspond to which triangles. t_e(T,i) represents the ith edge
%         in triangle T.
%     basis_p2 - a matrix representing piece-wise basis functions for 
%         each edge and triangle in each triangle. basis_p2(:,i,T)
%         represents the pieceiwise basis function for the ith node or 
%         midpoint in triangle T.
%     basis_nd1 - a matrix representing piece-wise basis functions for 
%         each edge and triangle in each triangle. basis_nd1(:,i,T)
%         represents the ith pieceiwise basis function in triangle T.
%     x - approximated solution
%     u_vec_r - exact solution vector r component
%     u_vec_z - exact solution vector z component
%     n - Hodge Laplacian on Axisymmetrix Domain and its discretization
%     weight
%
% Outputs:
%    err - L2 error
%
% Author: Nicole Stock
% Date: Fall 2020

[~,nodes] = size(p);
[~,midpoints] = size(p2);
[~,triangles] = size(t);
[edges,~] = size(ed);
integral = 0;

for T = 1:triangles
    
    % get coordinates of triangle T
    coordinates = zeros(3,2);
    for N = 1:3
        node = t(N,T);
        % get x,y coordinates
        coordinates(N,:) = p(:,node);
    end
        
    [X,Y,Wx,Wy] = triquad(7, coordinates);

    % P2 Basis Function
    basis_p2_r = @(r,z,i) (-1./n).*(basis_p2(1,i,T).*r.^2 ...
        + basis_p2(2,i,T).*r.*z ...
        + basis_p2(3,i,T).*z.^2 + basis_p2(4,i,T).*r ...
        + basis_p2(5,i,T).*z + basis_p2(6,i,T));
    basis_p2_th = @(r,z,i) basis_p2(1,i,T).*r.^2 + basis_p2(2,i,T).*r.*z ...
        + basis_p2(3,i,T).*z.^2 ...
        + basis_p2(4,i,T).*r + basis_p2(5,i,T).*z ...
        + basis_p2(6,i,T);
    % basis_p2_z = 0;
    
    % ND1 Basis Function
    basis_nd1_r = @(r,z,i) (1./n).*(basis_nd1(1,i,T).*r.^2 ...
        + basis_nd1(2,i,T).*r.*z + basis_nd1(3,i,T).*r ...
        - basis_nd1(7,i,T).*r.^2.*z - basis_nd1(8,i,T).*r.*z.^2);
    %basis_nd1_th = 0;
    basis_nd1_z = @(r,z,i) (1./n).*(basis_nd1(4,i,T).*r.^2 ...
        + basis_nd1(5,i,T).*r.*z + basis_nd1(6,i,T).*r ...
        + basis_nd1(7,i,T).*r.^3 + basis_nd1(8,i,T).*r.^2.*z);

    approx_r = @(r,z) x(t(1,T)).*basis_p2_r(r,z,1) ...
        + x(t(2,T)).*basis_p2_r(r,z,2) + x(t(3,T)).*basis_p2_r(r,z,3) ...
        + x(nodes+t2(1,T)).*basis_p2_r(r,z,4) ...
        + x(nodes+t2(2,T)).*basis_p2_r(r,z,5) ...
        + x(nodes+t2(3,T)).*basis_p2_r(r,z,6) ...
        + x(nodes+midpoints+t_e(T,1)).*basis_nd1_r(r,z,1) ...
        + x(nodes+midpoints+edges+t_e(T,1)).*basis_nd1_r(r,z,2) ...
        + x(nodes+midpoints+t_e(T,2)).*basis_nd1_r(r,z,3) ...
        + x(nodes+midpoints+edges+t_e(T,2)).*basis_nd1_r(r,z,4) ...
        + x(nodes+midpoints+t_e(T,3)).*basis_nd1_r(r,z,5) ...
        + x(nodes+midpoints+edges+t_e(T,3)).*basis_nd1_r(r,z,6) ...
        + x(nodes+midpoints+2*edges+T).*basis_nd1_r(r,z,7) ...
        + x(nodes+midpoints+2*edges+triangles+T).*basis_nd1_r(r,z,8);

    approx_th = @(r,z) x(t(1,T)).*basis_p2_th(r,z,1) ...
        + x(t(2,T)).*basis_p2_th(r,z,2) + x(t(3,T)).*basis_p2_th(r,z,3) ...
        + x(nodes+t2(1,T)).*basis_p2_th(r,z,4) ...
        + x(nodes+t2(2,T)).*basis_p2_th(r,z,5) ...
        + x(nodes+t2(3,T)).*basis_p2_th(r,z,6);
        
    approx_z = @(r,z) x(nodes+midpoints+t_e(T,1)).*basis_nd1_z(r,z,1) ...
        + x(nodes+midpoints+edges+t_e(T,1)).*basis_nd1_z(r,z,2) ...
        + x(nodes+midpoints+t_e(T,2)).*basis_nd1_z(r,z,3) ...
        + x(nodes+midpoints+edges+t_e(T,2)).*basis_nd1_z(r,z,4) ...
        + x(nodes+midpoints+t_e(T,3)).*basis_nd1_z(r,z,5) ...
        + x(nodes+midpoints+edges+t_e(T,3)).*basis_nd1_z(r,z,6) ...
        + x(nodes+midpoints+2*edges+T).*basis_nd1_z(r,z,7) ...
        + x(nodes+midpoints+2*edges+triangles+T).*basis_nd1_z(r,z,8);
    
    % find L2 Error
    integrand =@(r,z) ((u_vec_r(r,z) - approx_r(r,z)).^2 ...
        + (u_vec_th(r,z) - approx_th(r,z)).^2 ...
        + (u_vec_z(r,z) - approx_z(r,z)).^2).*r;
    
    integral = integral + Wx'*feval(integrand,X,Y)*Wy;
end

err = sqrt(integral);
% end