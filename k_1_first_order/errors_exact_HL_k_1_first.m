function [err_u,err_s] = errors_exact_HL_k_1_first(p,t,p2,t2,ed,t_e,basis_p2,basis_nd1,u_h,u_vec_r,u_vec_th,u_vec_z,s_h,s,n)
% ERRORS_EXACT_HL_K_1_FIRST - Calculate the errors of our solutions
% compared to the exact solution.
%   Hodge Laplacian k = 1 case, first order
%
% Syntax:
%     [err_u,err_s] = 
%         errors_exact_HL_k_1_first
% Inputs:
%     p - a 2xNumNodes matrix representing nodal coordinates.
%     t - a 4xNumTriangles matrix representing the element connectivity in 
%         terms of node IDs. The end row of T represents the geometry face ID 
%         to which the element belongs.
%     p2 - a 2xNumNodes matrix representing midpoint nodal coordinates.
%     t2 - a 3xNumTriangles matrix representing the element connectivity in 
%         terms of node IDs. The three node IDs in a column are the three
%         midpoints of the node IDS in corresponding column in t.
%     ed - a 2xNumEdges matrix representing each edge as a row with
%         starting node in column 1 and the ending node in column 2.
%     t_e - a NumTrianglesx3 matrix representing the which edges
%         correspond to which triangles. t_e(T,i) represents the ith edge
%         in triangle T.
%     basis_p2 - a matrix representing piece-wise basis functions for 
%         each edge and triangle in each triangle. basis_p2(:,i,T)
%         represents the pieceiwise basis function for the ith node or 
%         midpoint in triangle T.
%     basis_nd1 - a matrix representing piece-wise basis functions for 
%         each edge and triangle in each triangle. basis_nd1(:,i,T)
%         represents the ith pieceiwise basis function in triangle T.
%     u_h - approximated solution of u
%     u_vec_r - exact solution u vector r component
%     u_vec_r - exact solution u vector theta component
%     u_vec_z - exact solution u vector z component
%     s_h - approximated solution of s
%     s - exact solution s
%     n - Fourier mode
%
% Outputs:
%    err_u - L2 error for u approximation
%    err_s - L2 error for s approximation
%
% Author: Nicole Stock
% Date: Fall 2020

[~,nodes] = size(p);
[~,midpoints] = size(p2);
[~,triangles] = size(t);
[edges,~] = size(ed);
integral_u = 0;
integral_s = 0;

for T = 1:triangles
    
    % get coordinates of triangle T
    coordinates = zeros(3,2);
    for i = 1:3
        node = t(i,T);
        % get x,y coordinates
        coordinates(i,:) = p(:,node);
    end
        
    [X,Y,Wx,Wy] = triquad(7, coordinates);

    % s_h (Ah1 space)
    basis_p2_fn = @(r,z,i) (1./n).*(basis_p2(1,i,T).*r.^3 ...
        + basis_p2(2,i,T).*r.^2.*z + basis_p2(3,i,T).*r.*z.^2 ...
        + basis_p2(4,i,T).*r.^2 + basis_p2(5,i,T).*r.*z ...
        + basis_p2(6,i,T).*r);

    % compute approximation for s_h
    approx_s =@(r,z) s_h(t(1,T)).*basis_p2_fn(r,z,1) ...
        + s_h(t(2,T)).*basis_p2_fn(r,z,2) ...
        + s_h(t(3,T)).*basis_p2_fn(r,z,3) ...
        + s_h(nodes+t2(1,T)).*basis_p2_fn(r,z,4) ...
        + s_h(nodes+t2(2,T)).*basis_p2_fn(r,z,5) ...
        + s_h(nodes+t2(3,T)).*basis_p2_fn(r,z,6);
     
    % find L2 Error for s
    integrand_s =@(r,z) ((s(r,z) - approx_s(r,z)).^2).*r;
    
    integral_s = integral_s + Wx'*feval(integrand_s,X,Y)*Wy;
    
    % u_h (Bh1 space)
    
    % P2 Basis Function
    basis_p2_r = @(r,z,i) (-1./n).*(basis_p2(1,i,T).*r.^2 ...
        + basis_p2(2,i,T).*r.*z ...
        + basis_p2(3,i,T).*z.^2 + basis_p2(4,i,T).*r ...
        + basis_p2(5,i,T).*z + basis_p2(6,i,T));
    basis_p2_th = @(r,z,i) basis_p2(1,i,T).*r.^2 ...
        + basis_p2(2,i,T).*r.*z + basis_p2(3,i,T).*z.^2 ...
        + basis_p2(4,i,T).*r + basis_p2(5,i,T).*z ...
        + basis_p2(6,i,T);
    % basis_p2_z = 0;
    
    % ND1 Basis Function
    basis_nd1_r = @(r,z,i) (1./n).*(basis_nd1(1,i,T).*r.^2 ...
        + basis_nd1(2,i,T).*r.*z + basis_nd1(3,i,T).*r ...
        - basis_nd1(7,i,T).*r.^2.*z - basis_nd1(8,i,T).*r.*z.^2);
    %basis_nd1_th = 0;
    basis_nd1_z = @(r,z,i) (1./n).*(basis_nd1(4,i,T).*r.^2 ...
        + basis_nd1(5,i,T).*r.*z + basis_nd1(6,i,T).*r ...
        + basis_nd1(7,i,T).*r.^3 + basis_nd1(8,i,T).*r.^2.*z);
    % compute approximations for u_h

    approx_r_u = @(r,z) u_h(t(1,T)).*basis_p2_r(r,z,1) ...
        + u_h(t(2,T)).*basis_p2_r(r,z,2) ...
        + u_h(t(3,T)).*basis_p2_r(r,z,3) ...
        + u_h(nodes+t2(1,T)).*basis_p2_r(r,z,4) ...
        + u_h(nodes+t2(2,T)).*basis_p2_r(r,z,5) ...
        + u_h(nodes+t2(3,T)).*basis_p2_r(r,z,6) ...
        + u_h(nodes+midpoints+t_e(T,1)).*basis_nd1_r(r,z,1) ...
        + u_h(nodes+midpoints+edges+t_e(T,1)).*basis_nd1_r(r,z,2) ...
        + u_h(nodes+midpoints+t_e(T,2)).*basis_nd1_r(r,z,3) ...
        + u_h(nodes+midpoints+edges+t_e(T,2)).*basis_nd1_r(r,z,4) ...
        + u_h(nodes+midpoints+t_e(T,3)).*basis_nd1_r(r,z,5) ...
        + u_h(nodes+midpoints+edges+t_e(T,3)).*basis_nd1_r(r,z,6) ...
        + u_h(nodes+midpoints+2*edges+T).*basis_nd1_r(r,z,7) ...
        + u_h(nodes+midpoints+2*edges+triangles+T).*basis_nd1_r(r,z,8);

    approx_th_u = @(r,z) u_h(t(1,T)).*basis_p2_th(r,z,1) ...
        + u_h(t(2,T)).*basis_p2_th(r,z,2) ...
        + u_h(t(3,T)).*basis_p2_th(r,z,3) ...
        + u_h(nodes+t2(1,T)).*basis_p2_th(r,z,4) ...
        + u_h(nodes+t2(2,T)).*basis_p2_th(r,z,5) ...
        + u_h(nodes+t2(3,T)).*basis_p2_th(r,z,6);
        
    approx_z_u = @(r,z) u_h(nodes+midpoints+t_e(T,1)).*basis_nd1_z(r,z,1) ...
        + u_h(nodes+midpoints+edges+t_e(T,1)).*basis_nd1_z(r,z,2) ...
        + u_h(nodes+midpoints+t_e(T,2)).*basis_nd1_z(r,z,3) ...
        + u_h(nodes+midpoints+edges+t_e(T,2)).*basis_nd1_z(r,z,4) ...
        + u_h(nodes+midpoints+t_e(T,3)).*basis_nd1_z(r,z,5) ...
        + u_h(nodes+midpoints+edges+t_e(T,3)).*basis_nd1_z(r,z,6) ...
        + u_h(nodes+midpoints+2*edges+T).*basis_nd1_z(r,z,7) ...
        + u_h(nodes+midpoints+2*edges+triangles+T).*basis_nd1_z(r,z,8);
    
    % find L2 Error for u
    integrand_u =@(r,z) ((u_vec_r(r,z) - approx_r_u(r,z)).^2 ...
        + (u_vec_th(r,z) - approx_th_u(r,z)).^2 ...
        + (u_vec_z(r,z) - approx_z_u(r,z)).^2).*r;
    
    integral_u = integral_u + Wx'*feval(integrand_u,X,Y)*Wy;
end

err_u = sqrt(integral_u);
err_s = sqrt(integral_s);
% end